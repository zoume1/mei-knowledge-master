---
title: python+vue+Electron构建桌面应用
date: 2025-12-25 13:45:15
permalink: /pages/7fd418/
categories:
  - python
  - 综合使用
tags:
    -
---
前言

我很想要一个python作为脚本在后台帮我做事情，vue写一个前端页面，然后打包成exe桌面应用，这样我就可以得到一个有互动的脚本，好了 我要来实现了........

# Step 1. 创建项目

**(注意只能使用node20.19.*以上的，不然会报错)**

```sh
# 创建并进入项目目录
mkdir electron-vue-demo
cd electron-vue-demo

# 使用 electron-vite 创建项目
npm create @quick-start/electron@latest

# 选择配置：
Project name: … <electron-app>
✔ Select a framework: › vue
✔ Add TypeScript? … No / Yes
✔ Add Electron updater plugin? … No / Yes
✔ Enable Electron download mirror proxy? … No / Yes

Scaffolding project in ./<electron-app>...
Done.
```

# Step 2.项目结构

```sh
electron-vue-demo/
├─ src/
│  ├─ main/        # Electron 主进程
│  │  └─ index.js  # 主进程入口
│  ├─ preload/     # 预加载脚本
│  │  └─ index.js
│  ├─ renderer/    # Vue 前端代码
│  │  ├─ src/
│  │  ├─ App.vue
│  │  └─ main.js
│  └─ python/      # Python 脚本（自己创建）
│     └─ test.py
├─ electron.vite.config.js
└─ package.json
```



## Step 3.Python 脚本

创建 `src/python/test.py`:

```py
import sys
import json

def main():
    # 获取参数
    # sys.argv是一个列表，包含了运行Python脚本时命令行输入的所有参数  
    # sys.argv[0]是脚本本身的文件名  
    # sys.argv[1:]表示从第1个参数开始到最后，也就是去掉脚本名后的所有参数  
    args = sys.argv[1:]
  
    # 返回结果
    result = {
        "message": "Python 收到的参数",
        "args": args
    }
  
    # 打印 JSON 结果
    print(json.dumps(result))

if __name__ == "__main__":
    main()
```


## Step 4.主进程代码


```js
// app app名字，BrowserWindow窗口  是一个创造函数
import { app, shell, BrowserWindow, ipcMain } from 'electron'
import { join } from 'path'
import { electronApp, optimizer, is } from '@electron-toolkit/utils'
import { spawn } from 'child_process' // 用于直接执行一个可执行文件
import icon from '../../resources/icon.png?asset'
const path = require('path');

function createWindow(): void {
  // 创建主窗口
  const mainWindow = new BrowserWindow({
    width: 900, //窗口长度  
    height: 670, //窗口宽度
    show: false,// 初始不显示，等内容准备好后再显示
    autoHideMenuBar: true, //自带的导航是否不展示
    ...(process.platform === 'linux' ? { icon } : {}), //Linux 下设置窗口图标
    webPreferences: {
      preload: join(__dirname, '../preload/index.js'),// 预加载脚本
      sandbox: false// 关闭沙箱
    }
  })
  // mainWindow.webContents.openDevTools()

  // 当窗口内容渲染完成后再显示窗口，提升用户体验，避免显示空白或加载过程。
  mainWindow.on('ready-to-show', () => {
    mainWindow.show()
  })
// 外部链接处理  
// 拦截所有新窗口打开请求（如 <a target="_blank">），用系统默认浏览器打开外部链接，防止 Electron 内部打开不安全页面。
  mainWindow.webContents.setWindowOpenHandler((details) => {
    shell.openExternal(details.url)
    return { action: 'deny' }
  })
  // 设置宽松的Content-Security-Policy(CSP)规则
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;"
          + " script-src * 'unsafe-inline' 'unsafe-eval' data: blob:;"
          + " connect-src * data: blob:;"
          + " img-src * data: blob:;"
          + " style-src * 'unsafe-inline' data: blob:;"
          + " font-src * data: blob:;"
        ]
      }
    })
  })

   // 开发/生产环境区分加载页面
  // 开发环境下加载本地开发服务器（支持热重载）。
  // 生产环境下加载打包好的本地 HTML 文件。
  if (is.dev && process.env['ELECTRON_RENDERER_URL']) {
    mainWindow.loadURL(process.env['ELECTRON_RENDERER_URL'])
  } else {
    mainWindow.loadFile(join(__dirname, '../renderer/index.html'))
  }
}
  console.log(process.resourcesPath)
// 应用初始化与快捷键管理
app.whenReady().then(() => {
  // 为 Windows 设置应用模型 ID，便于系统识别。
  electronApp.setAppUserModelId('com.electron')

  // 开发环境下支持 F12 打开/关闭开发者工具，生产环境下禁用刷新等快捷键。
  // see https://github.com/alex8088/electron-toolkit/tree/master/packages/utils
  app.on('browser-window-created', (_, window) => {
    optimizer.watchWindowShortcuts(window)
  })

 // 主进程监听 ping 消息，收到后打印 pong，用于测试主进程和渲染进程的通信。
  ipcMain.on('ping', () => console.log('pong'))

  createWindow()
  // 当窗口被激活的时候
  app.on('activate', function () {
    // On macOS it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    // BrowserWindow.getAllWindows()  当窗口没有的时候
    if (BrowserWindow.getAllWindows().length === 0) createWindow()
  })
})

// 最后一个窗口被关闭时退出应用
app.on('window-all-closed', () => {
  // 如果你的系统不是苹果
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

// 主进程代码可扩展
// 你可以在这个文件继续写主进程相关代码，也可以把主进程功能拆分到其他文件再引入进来，方便项目结构管理。

// 监听 IPC 调用
// ipcMain.handle 用于注册一个异步的 IPC 处理器，监听渲染进程通过 ipcRenderer.invoke('run-python', args) 发来的请求。
// 'run-python' 是消息通道名。
// args 是渲染进程传过来的参数。
ipcMain.handle('run-python', async (_event, args) => {
  return new Promise((resolve, reject) => {
    let scriptPath
    if (app.isPackaged) {
      // 打包后
          scriptPath = path.join(process.resourcesPath, 'python', 'test.exe')
        } else {
          // 开发环境
          scriptPath = path.join(__dirname, '../../src/python/test.py')
    }
    let pythonPath
    let pythonProcess
    if(app.isPackaged){
      pythonPath = scriptPath
      pythonProcess = spawn(pythonPath, [...(args || [])])
    }else{
      pythonPath = 'python'
      pythonProcess = spawn(pythonPath, [scriptPath, ...(args || [])])
    }
    pythonProcess.stdout.on('data', (data) => {
        resolve(JSON.parse(data))
        console.log(`stdout: ${data}`);
    });

      pythonProcess.stderr.on('data', (data) => {
        reject(data)
        console.error(`stderr: ${data}`);
      });

      pythonProcess.on('close', (code) => {
        reject(code)
        console.log(`子进程退出码：${code}`);
      });
     })
})

```

## Step 5.预加载脚本

修改 `src/preload/index.js`:

```js
// Electron 提供的安全 API，用于在预加载脚本中把主进程/Node 能力暴露给渲染进程（前端页面）。
// ipcRenderer：Electron 提供的渲染进程与主进程通信的模块，可以用来发送/接收消息。
import { contextBridge, ipcRenderer } from 'electron'
// electronAPI：@electron-toolkit/preload 提供的 Electron 常用 API 封装。
import { electronAPI } from '@electron-toolkit/preload'

// 定义一个空对象 api，你可以在这里添加自定义的前后端通信方法，后续可以扩展。
const api = {
  //runPython 是一个函数，接收参数 args。
  //内部通过 ipcRenderer.invoke 发送一个名为 'run-python' 的异步消息到主进程，并传递参数 args。
  //主进程收到 'run-python' 消息后，会执行对应的处理（比如运行 Python 脚本），并把结果返回给渲染进程。
  //这是一个Promise，前端可以用 await window.api.runPython(args) 获取结果。
  runPython: (args) => ipcRenderer.invoke('run-python', args)
}

// 判断是否启用 context isolation
// context isolation（上下文隔离）是 Electron 的安全机制，推荐开启。
// 如果启用，渲染进程和 Node 环境完全隔离，不能直接访问 Node API，必须用 contextBridge 暴露。
// 如果没启用，可以直接挂到 window 全局对象（不安全，开发阶段常用）。
if (process.contextIsolated) {
  try {
    // 安全暴露 API
    // 用 contextBridge 把 electronAPI 和自定义的 api 安全地暴露到渲染进程的 window 对象上。
    // 这样前端页面可以通过 window.electron 和 window.api 访问这些 API。
    contextBridge.exposeInMainWorld('electron', electronAPI)
    contextBridge.exposeInMainWorld('api', api)
  } catch (error) {
    console.error(error)
  }
} else {
  // 非隔离模式下直接挂载
  // 如果没启用 context isolation，直接把 API 挂到 window，前端页面可以直接访问。
  window.electron = electronAPI
  window.api = api
}

```


## Step6. Vue 组件

```vue
<template>
  <div class="container">
    <h1>Electron + Vue + Python 示例</h1>
    <div class="input-group">
      <input v-model="inputText" placeholder="输入参数">
      <button @click="runPython">运行 Python</button>
    </div>

    <div class="result" v-if="result">
      <h3>Python 返回结果：</h3>
      <pre>{{ result }}</pre>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const inputText = ref('')
const result = ref(null)

async function runPython() {
  try {
    const args = inputText.value.split(' ').filter(Boolean)
    result.value = await window.api.runPython(args)
    console.log(result.value);
  
  } catch (error) {
    result.value = { error: String(error) }
  }
}
</script>

<style>
.container {
  padding: 20px;
}

.input-group {
  margin: 20px 0;
}

input {
  padding: 8px;
  margin-right: 10px;
}

button {
  padding: 8px 16px;
}

.result {
  margin-top: 20px;
  padding: 10px;
  background: #f5f5f5;
  border-radius: 4px;
  color: #000;
}

pre {
  white-space: pre-wrap;
}
</style>

```


## Step7.入口文件

修改 `src/renderer/src/main.js`:

```ts
import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')
import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')
```

Step8.入口文件

## Step8.配置文件

修改 `electron.vite.config.js`:

```js
import { resolve } from 'path'
import { defineConfig,externalizeDepsPlugin  } from 'electron-vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  main: {
      // 使用 externalizeDepsPlugin 插件，将 node_modules 里的依赖包自动标记为外部依赖，避免被打包进主进程产物，提升构建速度和兼容性。
    plugins: [externalizeDepsPlugin()]
  },
  preload: {
      plugins: [externalizeDepsPlugin()]
  },
  renderer: {
    resolve: {
      alias: {
        '@renderer': resolve('src/renderer/src')
      }
    },
    plugins: [vue()]
  }
})

```


## Step9.运行和测试

这里就不多展示

## Step10.打包


### 打开调试窗口

```js
// src/main/index.js
const { app, BrowserWindow, globalShortcut } = require('electron')

let mainWindow

function createWindow() {
  mainWindow = new BrowserWindow({
    // ...你的窗口参数...
  })

  // 你的其他窗口初始化代码...
  // 打开调试窗口，打包的时候删除这行  
  mainWindow.webContents.openDevTools()
}
```


### 打包python

此时运行打包命令python将无法执行，因为python文件并没有被一起打包过去。

**electron-vite** 实际上是用 [electron-builder **(opens new window)**](https://www.electron.build/)进行最终的安装包打包，所以**把 Python 文件或可执行文件打包进安装包**的方法和 electron-builder 是一样的，关键在于配置 `extraResources`。

1. 在项目中放置你的 Python 文件

Python 文件在 `src/python/test.py`，你也可以放在其他目录。

2. 配置 `extraResources`（关键步骤）

在你的 `package.json` 里添加（或修改）`build.extraResources` 字段：

```js
"build": {
  "extraResources": [
    {
      "from": "src/python",   // 源目录（相对项目根目录）
      "to": "python"          // 安装包里的目标目录
    }
  ]
}
```

这样，打包后 `src/python` 目录下的所有文件（包括 test.py）都会被复制到安装包的 `resources/python/` 目录下。



3. Electron 代码中获取正确路径

打包后，资源文件会被放在 `resources` 目录下。你需要这样获取路径：

```js
const { app } = require('electron')
const path = require('path')

let scriptPath
if (app.isPackaged) {
  // 打包后
  scriptPath = path.join(process.resourcesPath, 'python', 'test.py')
} else {
  // 开发环境
  scriptPath = path.join(__dirname, '../../src/python/test.py')
}
```

5. 打包命令

```bash
npm run build
npm run build:win   # 或 build:mac、build:linux
```

6. 检查打包结果
7. 安装后，去你的应用安装目录（如 `C:\Users\你的用户名\AppData\Local\你的应用名\resources\python\test.py`）确认 Python 文件是否存在。 然后实际运行一下安装的文件，注意，自己的电脑上需要安装python

## 13.将python打包成exe

在 Electron 项目中**自动完成 Python 脚本的打包**，并把生成的 exe 一起打包进 Electron 安装包。这样用户电脑就不用特意安装python了

### [#](https://daodao-knowledge.pages.dev/pages/7c4c4b/#_1-%E5%9C%A8-electron-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90-pyinstaller-%E6%89%93%E5%8C%85)1. 在 Electron 项目中集成 PyInstaller 打包

#### [#](https://daodao-knowledge.pages.dev/pages/7c4c4b/#_1-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC-build-python-js)（1）在项目根目录新建一个脚本， `build-python.js`：

```js
// build-python.js
const { execSync } = require('child_process')
const path = require('path')

const scriptPath = path.join(__dirname, 'src/python/test.py')

console.log('正在用 PyInstaller 打包 Python 脚本...')
execSync(`pyinstaller -F "${scriptPath}"`, { cwd: path.join(__dirname, 'src/python'), stdio: 'inherit' })
console.log('Python 脚本打包完成！')
```

#### [#](https://daodao-knowledge.pages.dev/pages/7c4c4b/#_2-%E5%9C%A8-package-json-%E7%9A%84-scripts-%E9%87%8C%E5%8A%A0%E4%B8%80%E6%9D%A1)（2）在 `package.json` 的 `scripts` 里加一条：

```json
"scripts": {
  // ... 其他命令 ...
  "build:python": "node build-python.js",
  "build": "npm run build:python && electron-vite build",
  "build:win": "npm run build:python && electron-vite build && electron-builder --win"
}
```

这样每次 `npm run build` 或 `npm run build:win` 都会先自动打包 Python 脚本。

---

### [#](https://daodao-knowledge.pages.dev/pages/7c4c4b/#_2-%E9%85%8D%E7%BD%AE-electron-builder-%E6%89%93%E5%8C%85-exe)2. 配置 electron-builder 打包 exe

在 `package.json` 里添加（或修改）`build.extraResources`：

```json
"build": {
  "extraResources": [
    {
      "from": "src/python/dist",
      "to": "python"
    }
  ]
}
```

这样打包后，`test.exe` 会被放到安装包的 `resources/python/test.exe` 目录下。

---

### [#](https://daodao-knowledge.pages.dev/pages/7c4c4b/#_3-electron-%E4%B8%BB%E8%BF%9B%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8-exe)3. Electron 主进程中调用 exe

```js
import { app, shell, BrowserWindow, ipcMain,globalShortcut } from 'electron'
import { join } from 'path'
import { electronApp, optimizer, is } from '@electron-toolkit/utils'
import { execFile, spawn, exec } from 'child_process'

//...
let scriptPath
if (app.isPackaged) {
    // 打包后
    scriptPath = join(process.resourcesPath, 'python', 'test.exe')
} else {
    // 开发环境
    scriptPath = join(__dirname, '../../src/python/test.py')
}

// 用 spawn 启动一个新的 Python 进程，执行 test.py，并传递参数。
// spawn 可以实时获取子进程的输出（比 execFile 更适合流式输出）。但是需要spawn专门去监听数据改变
//在开发环境和打包好的环境下运行python脚本调用传参略微有点不同，因为我们打包好的时候python脚本已经是exe文件了，因此不需要传scriptPath  
let pythonPath
    if(app.isPackaged){
      pythonPath = scriptPath
      pythonProcess = spawn(pythonPath, [...(args || [])])
    }else{
      pythonPath = 'python'
      pythonProcess = spawn(pythonPath, [scriptPath, ...(args || [])])
    }
    //spawn专门去监听数据改变
    pythonProcess.stderr.on('data', (data) => {
        reject(data)
        console.error(`stderr: ${data}`);
      });

      pythonProcess.on('close', (code) => {
        reject(code)
        console.log(`子进程退出码：${code}`);
      });
//....
```

---

### [#](https://daodao-knowledge.pages.dev/pages/7c4c4b/#_4-%E4%B8%80%E9%94%AE%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B)4. 一键打包流程

1. **开发环境下**，先安装好 pyinstaller（只需一次）：

   ```bash
   pip install pyinstaller
   ```
2. **打包命令**（自动完成 Python 脚本打包+Electron 打包）：

   ```bash
   npm run build:win
   ```

   或

   ```bash
   npm run build
   ```

---

### [#](https://daodao-knowledge.pages.dev/pages/7c4c4b/#_5-%E6%B3%A8%E6%84%8F)5. 注意

* 如果有多个 Python 脚本，可以在 `build-python.js` 里循环打包。
* 如果 Python 脚本有依赖第三方库，建议用虚拟环境，pyinstaller 会自动分析依赖。
* 如果你想在 Mac 或 Linux 下也支持，pyinstaller 需要在对应系统下打包。
