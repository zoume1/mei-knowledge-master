---
title: 请求接口以及生成xlsx文件
date: 2026-02-02 10:01:31
permalink: /pages/721b29/
categories:
  - python
tags:
    -
---
公司最近需要整理一些数据生成xlsx文件，居然让我们前端去一个一个复制下来整理！！！，破公司，想偷懒，写个脚本自己去弄吧

整理一下思路

1.先把接口找出来 ，然后伪装成浏览器的请求，找到接口有两个，一个get获取监测项传感器列表，一个根据传感器id获取数据列表

```py
  # get.py
#先写一个get方法
import requests
def getRq(urlStr):
    url = urlStr
    params = {
        "projectType": "project_type_bridgeGroup",
    }
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36",
        "authorization":"***" #携带的身份认证
    }
    response = requests.get(url=url, params=params, headers=headers)
    if response.status_code == 200:  # 确保请求成功再解析
        json_data = response.json()  # 内置JSON解析方法，直接返回Python字典/列表
        # print(f"解析后的JSON数据类型：{json_data}")
        return json_data
```

```python
#另外一个post接口，我也写成一个函数，这样不会显得主页面代码乱，可阅读性强点
import requests
def postRq(urlStr,id,structId ):
    url = urlStr  # POST测试接口
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0 Safari/537.36",
        "Content-Type": "application/json",
        "authorization":***"# 可省略，用json参数会自动设置
    }
    # JSON格式请求体（直接传字典，requests自动序列化）
    json_data = {
        "size":100,
         "current":1,
         "structId":structId,
         "monitorContentCode":id,
         "beginTime":"2026-01-23 00:00:00",
         "endTime":"2026-01-23 23:59:59",
         "pointNo":""
    }

    # 发送POST请求（json参数传递JSON体）
    response = requests.post(url=url, headers=headers, json=json_data)

    # 处理响应
    if response.status_code == 200:
        result = response.json()
        return result
        prin
```

2.组装数据，生成xlsx文件，然后成功完成这个功能，完美！！

```python


#导入方法文件
import get  
import post
#这是生成xlsx的插件
from openpyxl import Workbook#最主要的主文件
getstr = get.getRq('地址')

# 初始化工作簿和工作表
wb = Workbook()
ws = wb.active
ws.title = "文件"
# 定义表头（与字典键对应）
headers = ["监测内容", "测点编号", "测点位置","测量值","平均值","最大值","最小值","标准差","方差","极差（最大-最小）"]
# 写入表头
ws.append(headers)

# # 获取最后一个节点的id
def each(arr):
    for item in arr:
        if len(item.get('children')) > 0: each(item.get('children'))
        # else: result = post.postRq('http://110.53.0.3:18080/api/iot-tnt/monitoring/data/history-data/statistics',item.get('id'))
        else:
            if item.get('id') == 'ExpansionDistance':
                result = post.postRq('地址',
                                     item.get('id'), item.get('parentId'))
                print(result.get('data').get('records'))
                for items in result.get('data').get('records'):
                    for rowItme in items['statisticalParamList']:
                        row = [
                            items["monitorContentName"],  # 直接取字典键值
                            items["pointNo"],
                            items["pointPosition"],
                            rowItme["measureValueName"],
                            rowItme["avg"],
                            rowItme["max"],
                            rowItme["min"],
                            rowItme["stdDev"],
                            rowItme["variance"],
                            rowItme["range"]

                        ]
                        ws.append(row)
            try:
                wb.save('excel.xlsx')
                print(f"Excel文件生成成功：'excel.xlsx")
                return True
            except PermissionError:
                print(f"权限不足，无法保存文件（可能Excel已打开）")
                return False
            except Exception as e:
                print(f"Excel生成失败：{str(e)}")
                return False
                # f=open('data.json','w',encoding='utf-8')
                # f.write(json.dumps(result.get('data').get('records')))
                # f.close()
#
#     # return result  # 返回计算结果
#
# # 2. 使用json_data（字典操作示例）
if 'getstr' in locals():  # 确保json_data成功生成
    if  getstr.get('code') == 1000:
        print(getstr.get('data'))
        each(getstr.get('data'))


```
中间遇到的教训
1.格式一定要对齐，不然分分钟报错给你看
2.生成文件一定要用try去生成，不然也报错，等我去了解一下为啥，后面再补充